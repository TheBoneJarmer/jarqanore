# JArqanore

## About
JArqanore is a Java wrapper for my other library, [Arqanore](https://github.com/thebonejarmer/arqanore), which was written in C++. JArqanore uses the Java Native Interface to wrap Arqanore's functionality and make it available in Java. Therefore, JArqanore is also partly C++ and the decision was made to use build scripts to make the build flow a lot easier.

Because of its nature, JArqanore only runs on the platforms supported by Arqanore. Furthermore, Arqanore and all of its dependencies need to be installed separately to build JArqanore. Due to the many requirements Arqanore has I did not include a pre-compiled library in this repo. If you wish to build JArqanore, you need to do so yourself. See below for more details.

## Building
### Arqanore
As stated earlier, you will have to clone Arqanore and follow the instructions in the README file there. The following instructions are going to assume you built and installed Arqanore already.

> **Tip!** It may be interesting to try running the examples in the Arqanore repo to make sure the library works. JArqanore assumes Arqanore will work so any crashes caused by a faulty library installation or compilations are not covered and could result into nasty errors. If this happens regardless, look for error logs generated by the JVM. These usually have a filename like `hs_pid_error.log`. This will tell you more.

## Installation
JArqanore comes with a different version per operating system. Download the JAR file for your OS and include it in your project as a local dependency.

## Usage

```java
import be.labruyere.arqanore.*;
import be.labruyere.arqanore.enums.Keys;

public class App {
    private static Window window;
    
    private static void onOpen() {
        // Load assets and initialize stuff here
    }

    private static void onClose() {
        // Delete pointers here
    }

    private static void onUpdate(double at) {
        // It is highly recommended to use try-catch statements in every callback. 
        // This is to ensure the onClose event is being called or else you will have corrupted memory!
        try {
            if (Keyboard.keyPressed(Keys.ESCAPE)) {
                window.close();
            }
        } catch (ArqanoreException e) {
            e.printStackTrace();
            window.close();
        }
    }
    
    private static void onRender2D() {
        // Render sprites, text and polygons here!
    }

    private static void onRender3D() {
        // Render 3D models here
    }

    public static void main(String[] args) {
        try {
            window = new Window(1440, 786, "App");
            window.onOpen("App", "onOpen");
            window.onClose("App", "onClose");
            window.onUpdate("App", "onUpdate");
            window.onRender3D("App", "onRender3D");
            window.onRender2D("App", "onRender2D");
            window.open(false, true, true);
        } catch (ArqanoreException ex) {
            ex.printStackTrace();
        }
    }
}
```

## Notes
### Dynamic loading of library files
JArqanore is always initialized automatically when you access one of its classes at runtime. When this happens, it generates a temp folder where it extracts all the .dll or .so files to. This folder is then used to load the libraries dynamically. Due to the nature of how operating systems look for libraries, this cannot be done through the JVM alone. This will work for `jarqanore.dll` (or `jarqanore.so` on Linux), but this will fail for all the depedency libraries for Arqanore since those are out of scope of the JVM. Why? Well, take a look at the following graph:

```
jarqanore.dll
--arqanore.dll
----glfw3.dll
```

As you can see, the top library is `jarqanore.dll`, which is loaded by the java function `System.load`. This is the same for`arqanore.dll`. But `glfw3.dll` is loaded by `arqanore.dll` and **not** the JVM. And thus, its loading strategy is OS-specific. Keep this in mind.

> **Warning!** On Linux, the RPATH is set during the linking stage of the native library. But no such thing exists on Windows. As a result, on Linux the temp file strategy will work but on Windows you need to modify the PATH env variable before running the app using JArqanore or place all the dependency dll files in the same folder as jarqanore.jar.

### Including dependencies
If you wish to include the dll or so files from Arqanore and its dependencies in the resulting jar file, create a folder `lib` in the root folder of this repo and put them there. The scripts will copy the contents of this folder to the out folder before generating the jar file.

### Native vs java library
JArqanore uses the Java Native Interface to make a connection between c++ and Java. So for this reason JArqanore is divided into a native library and a java library. The native library uses CMake as build tool and the java library uses the java compiler directly. I have looked into using Gradle but due to its nature compiling both Java and C++ at the same time is hard, if not near impossible. Any advise on how to approach that is welcome but until then I decided to settle with build scripts that do the job too.

> **Tip!** Unlike with Arqanore you do not have to install the resulting .dll file or .so file somewhere on the system. Instead it is packed in the resulting JAR file because it is essential and only useful to JArqanore.

### Scripts
To automate the build process a little I decided to create some scripts to help me with this. These scripts are resided in the root directory of this repo.

## Contributing
Pull requests are always welcome! But target the **develop** branch when you do so. Thanks in advance!